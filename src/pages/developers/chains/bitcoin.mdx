Interacting with universal contracts on ZetaChain from Bitcoin happens through
the Bitcoin Gateway, a threshold signature scheme (TSS) address. The private key
to this address is distributed among ZetaChain's validator set using MPC.

The Bitcoin Gateway supports the following operations:

- Deposit: Send BTC to a ZetaChain account or contract.
- Call: Trigger a smart contract on ZetaChain using a BTC transaction.
- Deposit and Call: Deposit BTC and immediately invoke a contract.

There are two ways to interact with the Bitcoin Gateway:

| Method       | Max Payload  | Cost          | Revert Address | Best For                             |
| ------------ | ------------ | ------------- | -------------- | ------------------------------------ |
| Inscriptions | >520 bytes   | Higher (2 tx) | Customizable   | ABI-encoded calls and large payloads |
| OP_RETURN    | \~60 bytes\* | Lower (1 tx)  | Matches sender | Simple deposits and small payloads   |

\* Not counting the required 20 bytes for the universal contract address.

## Inscriptions

Inscriptions enable rich interaction between Bitcoin and ZetaChain by embedding
structured metadata into Bitcoin transactions using a commit-reveal flow. This
method encodes ABI data and optional Bitcoin revert logic into the Bitcoin
blockchain.

Commit and Reveal Each interaction consists of two Bitcoin transactions:

- Commit: Encodes the payload as a Taproot-inscribed output. It commits to the
  data but doesn't reveal it yet.
- Reveal: Broadcasts the actual data that was committed to, including logic for
  contract interaction on ZetaChain.

**‚úâÔ∏è Envelope Format (Witness Script)**

```
[OP_PUSHBYTES_32 <32-byte pubkey>] OP_CHECKSIG
OP_FALSE
OP_IF
  <payload> (1 or more pushes)
OP_ENDIF
```

**üß© Payload Format**

The inscription data consists of: a 4-byte ZetaChain header and BI- or
Compact-encoded fields (depending on format).

Header:

| Byte     | Description                                |
| -------- | ------------------------------------------ |
| `0x5a`   | Fixed identifier for ZetaChain inscription |
| Byte `1` | Encoding format (`0x00` = ABI, etc.)       |
| Byte `2` | Operation code (`0x10` = Call, etc.)       |
| Byte `3` | Constant: `0x07` (reserved flags)          |

**Fields**

Fields are encoded differently based on the encoding format.

**ABI encoding**

For calls involving structured input, ZetaChain uses Ethereum-style ABI
encoding. This allows full compatibility with Solidity contracts. You can pass
complex types like address, bytes, uint256[], etc., and encode them client-side
before embedding them in the inscription.

- Receiver address: A 20-byte Ethereum-style address of the ZetaChain account or
  universal contract.
- Payload: Optional encoded data (e.g., an ABI-encoded function call) for use in
  the contract‚Äôs onCall handler.
- Revert address: A Bitcoin address to which funds will be returned if the
  cross-chain call fails.

| Field    | Value                                        |
| -------- | -------------------------------------------- |
| Header   | 4 bytes                                      |
| ABI data | abi.encode(receiver, payload, revertAddress) |

**Compact encoding**

Each field is encoded in a more concise form:

```
[receiver (20 bytes)] + [len][payload bytes] + [len][revert address bytes]
```

- Receiver is raw 20 bytes
- Payload and Revert Address are length-prefixed:
  - CompactShort: 1-byte length prefix (max 255 bytes)
  - CompactLong: 2-byte length prefix (max 65535 bytes)

| Field    | Value                        |
| -------- | ---------------------------- |
| Header   | 4 bytes                      |
| Receiver | 20 bytes                     |
| Payload  | [len:1 or 2] + bytes         |
| Revert   | [len:1 or 2] + address bytes |

üì¶ Used when minimizing size matters, or ABI encoding is overkill.

üîÅ Operation Types (OpCode)

| Operation        | Code (`OpCode`) | Description                                                          |
| ---------------- | --------------- | -------------------------------------------------------------------- |
| `Deposit`        | `0x00`          | Only receiver, no payload. Optional revert address                   |
| `Call`           | `0x02`          | Sends no BTC, invokes onCall() with payload. Revert optional         |
| `DepositAndCall` | `0x01`          | Transfers BTC and invokes onCall() with payload. Revert **required** |

### Deposit

- No call data is included.
- BTC is deposited to the ZRC-20 equivalent on ZetaChain.
- Useful when transferring BTC as ZRC-20 BTC to an EOA on ZetaChain

üìå **Example:**

- [Commit
  TX](https://mempool.space/signet/tx/eaaabfe041c0784d31a5bb8db3ff255b31ae5bd4a81f918a73e39ab3d4f3cd8c)
- [Reveal
  TX](https://mempool.space/signet/tx/b1934876ab53b211fc1e3168bd0b4e2df6a5d9f3bd1be6c77a88666a7c9e926e)
- [Cross-chain
  TX](https://zetachain-athens.blockpi.network/lcd/v1/public/zeta-chain/crosschain/inboundHashToCctxData/b1934876ab53b211fc1e3168bd0b4e2df6a5d9f3bd1be6c77a88666a7c9e926e)

### Call

- The payload includes:
  - Contract address
  - Call data
- No BTC is transferred to the contract ‚Äî it's a logic-only interaction.
- Ideal for triggering universal contract execution that does not require BTC

üìå **Example:**

- [Commit
  TX](https://mempool.space/signet/tx/6c92cb80f093176b865c1431770e43c9264074d797acabbfee244f96751aac61)
- [Reveal
  TX](https://mempool.space/signet/tx/cdb52721e9787c94cda196304d9f699cc89d661c9946bac32f7bdfcf17e08eaa)
- [Cross-chain
  TX](https://zetachain-athens.blockpi.network/lcd/v1/public/zeta-chain/crosschain/inboundHashToCctxData/cdb52721e9787c94cda196304d9f699cc89d661c9946bac32f7bdfcf17e08eaa)

### Deposit and Call

- Combines the previous two:
  - BTC is transferred and
  - A contract function is invoked with encoded parameters.
- Enables rich interactions like "send BTC and trigger a swap", "deposit and
  mint", or any other cross-chain composable logic.

üìå **Example:**

- [Commit
  TX](https://mempool.space/signet/tx/ec1d9078affd6ce20b0b57a2cdd853b9224a2a9fae9ddf759082d7a944dddab4)
- [Reveal
  TX](https://mempool.space/signet/tx/0a05ed49545204d03db88daf5bfa93cc5e9177075701a4f27a3cb97d898a45)
- [Cross-chain
  TX](https://zetachain-athens.blockpi.network/lcd/v1/public/zeta-chain/crosschain/inboundHashToCctxData/0a05ed49545204d03db88daf5bfa93cc5e9177075701a4f27a3cb97d898a45)

## ‚úÖ When to Use Inscriptions

Use inscriptions when:

- Your payload exceeds 60 bytes (which OP_RETURN can‚Äôt handle)
- You need to encode structured ABI arguments
- You want to specify a custom revert address for fail-safety
- You‚Äôre triggering logic, not just transferring BTC

## OP_RETURN

This method involves sending a standard Bitcoin transaction with an `OP_RETURN`
output that encodes the recipient (universal contract or EOA) and an optional
short message.

### Deposit

To deposit BTC into a **ZetaChain account**, construct a Bitcoin transaction
with:

1. **First output**: BTC amount sent to the TSS Bitcoin address.
2. **Second output**: `OP_RETURN PUSH_x [DATA]`, where:

   - `[DATA] = 0x` + 20-byte recipient address on ZetaChain (Ethereum-style).

üìå **Example:**

- [Transaction](https://blockstream.info/testnet/tx/952d60fd9efc1aad4b87a8a7a6d57a972d49e084de8b5dc524e163216c11c04f)
- [Cross-chain
  TX](https://zetachain-athens.blockpi.network/lcd/v1/public/zeta-chain/crosschain/inboundHashToCctxData/952d60fd9efc1aad4b87a8a7a6d57a972d49e084de8b5dc524e163216c11c04f)

### Call

To call a universal contract on ZetaChain:

- `[DATA] = [contract address (20 bytes)] + [call payload (max 60 bytes)]`

This will execute the `onCall` method on the target contract.

‚ö†Ô∏è Keep payloads concise. Larger data should use inscriptions instead.

### Deposit and Call

Use the same format as a call, but ensure the BTC sent is used as part of the
operation.

## Fees

Unlike EVM-based chains, each deposited Bitcoin output incurs a fee when it is
spent. To address this, both the depositor and the withdrawer share the cost of
the spend. This fee is charged in advance as a deposit fee.

The Bitcoin deposit fee is calculated with the following formula:

```text
depositFee = (txFee / txVsize) * 68 vB * 2
```

Where:

- `txFee = totalInputValue - totalOutputValue`
- `txVsize` is the virtual size of the Bitcoin transaction.
