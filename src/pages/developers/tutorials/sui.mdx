Interacting with ZetaChain universal apps directly from the Sui blockchain is
straightforward and intuitive. You can deposit SUI tokens to ZetaChain
addressesâ€”both externally owned accounts (EOAs) and smart contracts. Universal
apps deployed on ZetaChain can accept these token deposits and handle contract
calls originating from Sui.

In this tutorial, you'll:

- Set up a local development environment using [localnet](/reference/localnet).
- Deploy a universal contract on ZetaChain.
- Deposit SUI tokens from Sui to ZetaChain.
- Execute deposit-and-call to deposit SUI tokens and call a universal app in a
  single transaction.

By the end, you'll clearly understand how Sui-based applications and contracts
can integrate seamlessly with the ZetaChain ecosystem.

## Prerequisites

Ensure you have installed and configured the following tools before starting:

- [Sui CLI](https://docs.sui.io/references/cli): Required for starting a local
  Sui node and interacting with it.
- [Foundry](https://getfoundry.sh/): Needed for encoding payload data using ABI.

## Clone the Example Project

Start by creating a project and installing the necessary dependencies:

```bash
npx zetachain@latest new --project call
cd call
yarn
```

## Launch Localnet

Start your local development environment, which sets up instances of ZetaChain
and Sui:

```bash
yarn zetachain localnet start
```

Keep this terminal window open. You should see a table displaying the deployment
details, including Gateway module and object IDs:

```
SUI
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)         â”‚ Values                                                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ gatewayModuleID â”‚ '0xc478ce1cbbeb090889a0e728af4fd25d80993a653b5f03090dbf77e5a9476bcd'           â”‚
â”‚ gatewayObjectId â”‚ '0x332483152b600f388b64adb4d98509ded379167df6047c49a564a4ed62f8bb71'           â”‚
â”‚ userMnemonic    â”‚ 'grape subway rack mean march bubble carry avoid muffin consider thing street' â”‚
â”‚ userAddress     â”‚ '0x2fec3fafe08d2928a6b8d9a6a77590856c458d984ae090ccbd4177ac13729e65'           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Deploying a Universal Contract

Open a new terminal window to compile and deploy your Universal Contract:

```bash
npx hardhat compile --force
npx hardhat deploy --name Universal --network localhost --gateway 0x5FC8d32690cc91D4c39d9d3abcBD16989F875707
```

A successful deployment will output:

```
ðŸš€ Successfully deployed "Universal" contract on localhost.
ðŸ“œ Contract address: 0x8198f5d8F8CfFE8f9C413d98a0A55aEB8ab9FbB7
```

## Deposit to ZetaChain

To deposit tokens from your local Sui Gateway contract to ZetaChain, use:

```
npx zetachain sui deposit \
  --mnemonic "grape subway rack mean march bubble carry avoid muffin consider thing street" \
  --receiver 0xFD6F7A6a5c21A3f503EBaE7a473639974379c351 \
  --gateway-package 0x6e142a9730f8d497905251074f0b4909c5fd47c6ea0668c0c643c7954b9f4d45 \
  --gateway-object 0x83b40ac9eb0a9fa6ce2d6e98f17d53cedaed72d00807719055ed24a99b8f3d6e \
  --amount 0.001 \
  --chain-id 104
```

In this example, a client makes a call on the Sui blockchain to the local
Gateway contract. The local development environment (Localnet) observes this
transaction similarly to how ZetaChain would in a live scenario, and as a
result, deposits ZRC-20 SUI tokens to the specified receiver address on
ZetaChain.

## Deposit and Call

Execute a deposit and simultaneously make a function call to a universal
contract on ZetaChain:

```
npx zetachain sui deposit-and-call \
  --mnemonic "grape subway rack mean march bubble carry avoid muffin consider thing street" \
  --receiver 0xFD6F7A6a5c21A3f503EBaE7a473639974379c351 \
  --gateway-package 0x6e142a9730f8d497905251074f0b4909c5fd47c6ea0668c0c643c7954b9f4d45 \
  --gateway-object 0x83b40ac9eb0a9fa6ce2d6e98f17d53cedaed72d00807719055ed24a99b8f3d6e \
  --amount 0.001 \
  --chain-id 104 \
  --types string \
  --values hello
```

In this example, a call is made from a client on the Sui blockchain to the local
Gateway contract. The local development environment (Localnet) observes this
call, deposits ZRC-20 SUI tokens to the specified receiver address on ZetaChain,
and then triggers the receiver contract on ZetaChain with the provided payload
(alice).

## Build and Deploy a Sui Contract

```
cd sui
```

The example is already configured to import the Gateway from a local directory,
from which it's published on localnet. On testnet and mainnet the Gateway will
be imported from a public repo, instead.

```toml filename="sui/Move.toml"
[dependencies]
gateway = { local = "/usr/local/share/localnet/protocol-contracts-sui"}
```

Build:

```
sui move build --force
```

Deploy:

```
SUI_CONTRACT=$(sui client publish \
  --skip-dependency-verification \
  --json 2>/dev/null | jq -r '.objectChanges[] | select(.type == "published") | .packageId') && echo $SUI_CONTRACT
```

```
0xdefdceb18b96981b3635688ec93838845eb3534991d312b7562e2c1c6e4367a0
```

We're using `jq` to get the published module ID, but you can skip this to see
the whole output.

## Get Coins from the Faucet

```
sui client faucet
```

## Deposit from a Sui Contract

Get one of the coins for the currently active address:

```
COIN=$(sui client objects \
  $(sui client active-address) \
  --json | jq -r '.[] | select(.data.type == "0x2::coin::Coin<0x2::sui::SUI>") | .data.objectId' | head -n 1) && echo $COIN
```

```
sui client call \
  --package $SUI_CONTRACT \
  --module connected \
  --function deposit \
  --type-args 0x2::sui::SUI \
  --args 0x188a31831156e0ca554123f4178d8e982aaa879f855b967de5f0e80950dc9e66 \
      $COIN \
      0x8198f5d8F8CfFE8f9C413d98a0A55aEB8ab9FbB7
```

- `--package`: package ID of the Sui contract deployed in the previous step
- `--args`:
  - Gateway Object ID from the table in the output of localnet
  - One of the coins owned by the current address
  - Recipient address on ZetaChain

## Deposit and Call a Universal Contract from Sui Contract

Get one of the coins for the currently active address:

```
COIN=$(sui client objects \
  $(sui client active-address) \
  --json | jq -r '.[] | select(.data.type == "0x2::coin::Coin<0x2::sui::SUI>") | .data.objectId' | head -n 1) && echo $COIN
```

```
sui client call \
  --package $SUI_CONTRACT \
  --module connected \
  --function deposit_and_call \
  --type-args 0x2::sui::SUI \
  --args 0x188a31831156e0ca554123f4178d8e982aaa879f855b967de5f0e80950dc9e66 \
      $COIN \
      0x8198f5d8F8CfFE8f9C413d98a0A55aEB8ab9FbB7
      $(cast abi-encode "function(string)" "alice")
```

Note that in this example we're calling the `deposit_and_call` function and
passing one more argument: the payload. ZetaChain does not impose any specific
encoding on the payload, but since you're calling an EVM universal contract on
ZetaChain, it's easier to use [ABI
encoding](https://docs.soliditylang.org/en/develop/abi-spec.html). Call
Foundry's `cast` (or any other tool) to encode a string.
