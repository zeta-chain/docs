ZetaChain enables Sui-based applications to interact directly with universal
smart contracts deployed on ZetaChain. Using ZetaChain’s universal
interoperability layer, Sui apps can:

- Deposit SUI and supported fungible tokens to ZetaChain
- Make cross-chain calls to universal contracts
- Receive cross-chain calls and token transfers from universal contracts

In this tutorial, you'll learn how to:

- Set up a local development environment with both ZetaChain and Sui
- Deploy a universal contract on ZetaChain
- Deposit SUI tokens from a Sui address to ZetaChain
- Make a cross-chain call to trigger a function on a universal contract

By the end, you’ll understand how to transfer assets and trigger logic on
ZetaChain from Sui, both from a client wallet and from a Sui smart contract.

## Prerequisites

Make sure the following tools are installed before you begin:

| Tool                                          | Purpose                                                                   |
| --------------------------------------------- | ------------------------------------------------------------------------- |
| [Sui CLI](https://docs.sui.io/references/cli) | Run a local Sui validator, manage addresses and objects, deploy contracts |
| [Foundry](https://getfoundry.sh/)             | Encode ABI payloads for cross-chain calls using `cast`                    |
| [Node.js](https://nodejs.org/en)              | Run the ZetaChain CLI and JavaScript-based tooling                        |
| [Yarn](https://yarnpkg.com/)                  | Install and manage project dependencies                                   |
| [jq](https://jqlang.org/)                     | Parse JSON output in shell scripts                                        |

## Clone the Example Project

Start by generating a new project using the ZetaChain CLI:

```bash
npx zetachain@latest new --project call
cd call
```

This sets up a ready-to-use example with Sui and ZetaChain contracts.

Install dependencies:

```bash
yarn
```

The project is now ready for local development and testing.

## Launch Localnet

Start a local development environment with both ZetaChain and Sui running side
by side:

```bash
yarn zetachain localnet start --chains sui
```

This command boots up:

- A local ZetaChain instance
- A local Sui validator
- Pre-deployed gateway contracts on both networks

Leave this terminal open. Once started, you’ll see a table like this:

```
SUI
┌──────────────────┬──────────────────────────────────────────────────────────────────────────────────┐
│ (index)          │ Values                                                                           │
├──────────────────┼──────────────────────────────────────────────────────────────────────────────────┤
│ gatewayPackageId │ '0x2f43a5df90e8fbbcf315f0ed0bd3818c348b66175bbfa57ebc45dce5a969e49f'             │
│ gatewayObjectId  │ '0xf016928f8ccd5d2420f4cb8639dfab39613836a0e1c486271322abf5e13db6e8'             │
│ userMnemonic     │ 'grape subway rack mean march bubble carry avoid muffin consider thing street'   │
│ userAddress      │ '0x2fec3fafe08d2928a6b8d9a6a77590856c458d984ae090ccbd4177ac13729e65'             │
│ tokenUSDC        │ '37242f8b5af2a2cd9a846688d9a36c4fb8dbd4284166f94788aa4f7e5e7c3153::token::TOKEN' │
└──────────────────┴──────────────────────────────────────────────────────────────────────────────────┘
```

> 💡 Keep this output handy. You’ll reference the `gatewayObjectId`,
> `gatewayModuleID`, and `userMnemonic` in later steps.

## Deploying a Universal Contract

You’ll now deploy a universal smart contract to ZetaChain.

First, grab the local Gateway address and a funded private key from your
localnet setup:

```bash
GATEWAY_ZETACHAIN=$(jq -r '.["31337"].contracts[] | select(.contractType == "gateway") | .address' ~/.zetachain/localnet/registry.json) && echo $GATEWAY_ZETACHAIN
```

```bash
PRIVATE_KEY=$(jq -r '.private_keys[0]' ~/.zetachain/localnet/anvil.json) && echo $PRIVATE_KEY
```

Then deploy the `Universal` contract:

```bash
UNIVERSAL=$(forge create Universal \
  --rpc-url http://localhost:8545 \
  --private-key $PRIVATE_KEY \
  --evm-version paris \
  --broadcast \
  --json \
  --constructor-args $GATEWAY_ZETACHAIN | jq -r .deployedTo) && echo $UNIVERSAL
```

## Deposit to ZetaChain

Now that your universal contract is deployed on ZetaChain, you can deposit SUI
tokens from the Sui Gateway contract to that contract address.

Use the following command to deposit tokens from Sui to your universal contract
on ZetaChain:

```bash
npx zetachain sui deposit \
  --mnemonic "grape subway rack mean march bubble carry avoid muffin consider thing street" \
  --receiver $UNIVERSAL \
  --gateway-package 0x2f43a5df90e8fbbcf315f0ed0bd3818c348b66175bbfa57ebc45dce5a969e49f \
  --gateway-object 0xf016928f8ccd5d2420f4cb8639dfab39613836a0e1c486271322abf5e13db6e8 \
  --amount 0.001 \
  --chain-id 104
```

> 🔎 Replace `--gateway-package` and `--gateway-object` with the values printed
> in your localnet output table.

This command calls the deposit function on the Sui Gateway contract. ZetaChain
observes the deposit event and propagates the deposit to ZetaChain by minting
ZRC-20 SUI tokens and transferring them to your universal contract.

## Deposit and Call

In this step, you’ll deposit SUI tokens from Sui and simultaneously trigger a
function call on the universal contract deployed on ZetaChain.

```bash
npx zetachain sui deposit-and-call \
  --mnemonic "grape subway rack mean march bubble carry avoid muffin consider thing street" \
  --receiver $UNIVERSAL \
  --gateway-package 0x6e142a9730f8d497905251074f0b4909c5fd47c6ea0668c0c643c7954b9f4d45 \
  --gateway-object 0x83b40ac9eb0a9fa6ce2d6e98f17d53cedaed72d00807719055ed24a99b8f3d6e \
  --amount 0.001 \
  --chain-id 104 \
  --types string \
  --values hello
```

This command calls the `deposit_and_call` function on the Sui Gateway contract,
transferring the specified SUI amount, encoding the payload (`"hello"`) using
the provided `--types` and `--values`, and triggering the `onCall` function on
the universal contract deployed on ZetaChain.

## Build and Deploy a Sui Contract

```
cd sui
```

The example is already configured to import the Gateway from a local directory,
from which it's published on localnet. On testnet and mainnet the Gateway will
be imported from a public repo, instead.

```toml filename="sui/Move.toml"
[dependencies]
gateway = { local = "/usr/local/share/localnet/protocol-contracts-sui"}
```

Build:

```
sui move build --force
```

Deploy:

```
SUI_CONTRACT=$(sui client publish \
  --skip-dependency-verification \
  --json 2>/dev/null | jq -r '.objectChanges[] | select(.type == "published") | .packageId') && echo $SUI_CONTRACT
```

```
0xdefdceb18b96981b3635688ec93838845eb3534991d312b7562e2c1c6e4367a0
```

We're using `jq` to get the published module ID, but you can skip this to see
the whole output.

## Get Coins from the Faucet

```
sui client faucet
```

## Deposit from a Sui Contract

Get one of the coins for the currently active address:

```
COIN=$(sui client objects \
  $(sui client active-address) \
  --json | jq -r '.[] | select(.data.type == "0x2::coin::Coin<0x2::sui::SUI>") | .data.objectId' | head -n 1) && echo $COIN
```

```
sui client call \
  --package $SUI_CONTRACT \
  --module connected \
  --function deposit \
  --type-args 0x2::sui::SUI \
  --args 0x188a31831156e0ca554123f4178d8e982aaa879f855b967de5f0e80950dc9e66 \
      $COIN \
      0x8198f5d8F8CfFE8f9C413d98a0A55aEB8ab9FbB7
```

- `--package`: package ID of the Sui contract deployed in the previous step
- `--args`:
  - Gateway Object ID from the table in the output of localnet
  - One of the coins owned by the current address
  - Recipient address on ZetaChain

## Deposit and Call a Universal Contract from Sui Contract

Get one of the coins for the currently active address:

```
COIN=$(sui client objects \
  $(sui client active-address) \
  --json | jq -r '.[] | select(.data.type == "0x2::coin::Coin<0x2::sui::SUI>") | .data.objectId' | head -n 1) && echo $COIN
```

```
sui client call \
  --package $SUI_CONTRACT \
  --module connected \
  --function deposit_and_call \
  --type-args 0x2::sui::SUI \
  --args 0x188a31831156e0ca554123f4178d8e982aaa879f855b967de5f0e80950dc9e66 \
      $COIN \
      0x8198f5d8F8CfFE8f9C413d98a0A55aEB8ab9FbB7
      $(cast abi-encode "function(string)" "alice")
```

Note that in this example we're calling the `deposit_and_call` function and
passing one more argument: the payload. ZetaChain does not impose any specific
encoding on the payload, but since you're calling an EVM universal contract on
ZetaChain, it's easier to use [ABI
encoding](https://docs.soliditylang.org/en/develop/abi-spec.html). Call
Foundry's `cast` (or any other tool) to encode a string.
