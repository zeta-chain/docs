## Using ThirdWeb

[Thirdweb](https://thirdweb.com/) is a web3 development platform that enables
developers to deploy and interact with smart contracts across EVM-compatible
blockchains.

- [Universal NFT on
  ZetaChain](https://thirdweb.com/0xe7508B5026f032b37663718192bA63a40954F2c0/ZetaChainUniversalNFT)
- [Universal NFT on
  EVM](https://thirdweb.com/0xe7508B5026f032b37663718192bA63a40954F2c0/EVMUniversalNFT)

## Installing from NPM

```
yarn add @zetachain/standard-contracts@v1.0.0-rc2
```

## Starting from Scratch

Contract on ZetaChain:

```solidity filename="contracts/ZetaChainUniversalNFT.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "@zetachain/standard-contracts/contracts/nft/contracts/zetachain/UniversalNFT.sol";

contract ZetaChainUniversalNFT is UniversalNFT {}
```

Contract on an EVM chain:

```solidity filename="contracts/EVMUniversalNFT.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "@zetachain/standard-contracts/contracts/nft/contracts/evm/UniversalNFT.sol";

contract EVMUniversalNFT is UniversalNFT {}
```

`UniversalNFT` is an upgradeable contract that uses [OpenZeppelin
UUPSUpgradeable](https://docs.openzeppelin.com/contracts/5.x/api/proxy#UUPSUpgradeable).
Instead of a `constructor` it uses the `initialize` function.

## Starting from an OpenZeppelin Template

If you already have an ERC-721 contract you want make universal or you prefer to
start from an OpenZeppelin template, you can import Universal NFT functionality
with just a few lines of code:

```solidity filename="contracts/ZetaChainUniversalNFT.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {ERC721Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import {ERC721BurnableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol";
import {ERC721EnumerableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import {ERC721PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol";
import {ERC721URIStorageUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol";
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

// Import UniversalNFTCore for universal NFT functionality
import "@zetachain/standard-contracts/contracts/nft/contracts/zetachain/UniversalNFTCore.sol";

contract UniversalNFT is
    Initializable, // Allows upgradeable contract initialization
    ERC721Upgradeable, // Base ERC721 implementation
    ERC721URIStorageUpgradeable, // Enables metadata URI storage
    ERC721EnumerableUpgradeable, // Provides enumerable token support
    ERC721PausableUpgradeable, // Allows pausing token operations
    OwnableUpgradeable, // Restricts access to owner-only functions
    ERC721BurnableUpgradeable, // Adds burnable functionality
    UUPSUpgradeable, // Supports upgradeable proxy pattern
    UniversalNFTCore // Custom core for additional logic
{
    uint256 private _nextTokenId; // Track next token ID for minting

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(
        address initialOwner,
        string memory name,
        string memory symbol,
        address payable gatewayAddress, // Include EVM gateway address
        uint256 gas, // Set gas limit for universal NFT calls
        address uniswapRouterAddress // Uniswap v2 router address for gas token swaps
    ) public initializer {
        __ERC721_init(name, symbol);
        __ERC721Enumerable_init();
        __ERC721URIStorage_init();
        __ERC721Pausable_init();
        __Ownable_init(initialOwner);
        __ERC721Burnable_init();
        __UUPSUpgradeable_init();
        __UniversalNFTCore_init(gatewayAddress, gas, uniswapRouterAddress); // Initialize universal NFT core
    }

    function safeMint(
        address to,
        string memory uri
    ) public onlyOwner whenNotPaused {
        // Generate globally unique token ID, feel free to supply your own logic
        uint256 hash = uint256(
            keccak256(
                abi.encodePacked(address(this), block.number, _nextTokenId++)
            )
        );

        uint256 tokenId = hash & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
    }

    // The following functions are overrides required by Solidity.

    function _update(
        address to,
        uint256 tokenId,
        address auth
    )
        internal
        override(
            ERC721Upgradeable,
            ERC721EnumerableUpgradeable,
            ERC721PausableUpgradeable
        )
        returns (address)
    {
        return super._update(to, tokenId, auth);
    }

    function _increaseBalance(
        address account,
        uint128 value
    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {
        super._increaseBalance(account, value);
    }

    function tokenURI(
        uint256 tokenId
    )
        public
        view
        override(
            ERC721Upgradeable,
            ERC721URIStorageUpgradeable,
            UniversalNFTCore // Include UniversalNFTCore for URI overrides
        )
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(
        bytes4 interfaceId
    )
        public
        view
        override(
            ERC721Upgradeable,
            ERC721EnumerableUpgradeable,
            ERC721URIStorageUpgradeable,
            UniversalNFTCore // Include UniversalNFTCore for interface overrides
        )
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyOwner {}

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }

    receive() external payable {} // Receive ZETA to pay for gas
}
```

```solidity filename="contracts/EVMUniversalNFT.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {ERC721Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import {ERC721BurnableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol";
import {ERC721EnumerableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import {ERC721PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol";
import {ERC721URIStorageUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol";
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

// Import UniversalNFTCore for universal NFT functionality
import "@zetachain/standard-contracts/contracts/nft/contracts/evm/UniversalNFTCore.sol";

contract UniversalNFT is
    Initializable,
    ERC721Upgradeable,
    ERC721EnumerableUpgradeable,
    ERC721URIStorageUpgradeable,
    ERC721PausableUpgradeable,
    OwnableUpgradeable,
    ERC721BurnableUpgradeable,
    UUPSUpgradeable,
    UniversalNFTCore // Add UniversalNFTCore for universal features
{
    uint256 private _nextTokenId; // Track next token ID for minting

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(
        address initialOwner,
        string memory name,
        string memory symbol,
        address payable gatewayAddress, // Include EVM gateway address
        uint256 gas // Set gas limit for universal NFT calls
    ) public initializer {
        __ERC721_init(name, symbol);
        __ERC721Enumerable_init();
        __ERC721URIStorage_init();
        __ERC721Pausable_init();
        __Ownable_init(initialOwner);
        __ERC721Burnable_init();
        __UUPSUpgradeable_init();
        __UniversalNFTCore_init(gatewayAddress, address(this), gas); // Initialize universal NFT core
    }

    function safeMint(
        address to,
        string memory uri
    ) public onlyOwner whenNotPaused {
        // Generate globally unique token ID, feel free to supply your own logic
        uint256 hash = uint256(
            keccak256(
                abi.encodePacked(address(this), block.number, _nextTokenId++)
            )
        );

        uint256 tokenId = hash & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }

    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyOwner {}

    // The following functions are overrides required by Solidity.

    function _update(
        address to,
        uint256 tokenId,
        address auth
    )
        internal
        override(
            ERC721Upgradeable,
            ERC721EnumerableUpgradeable,
            ERC721PausableUpgradeable
        )
        returns (address)
    {
        return super._update(to, tokenId, auth);
    }

    function _increaseBalance(
        address account,
        uint128 value
    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {
        super._increaseBalance(account, value);
    }

    function tokenURI(
        uint256 tokenId
    )
        public
        view
        override(
            ERC721Upgradeable,
            ERC721URIStorageUpgradeable,
            UniversalNFTCore // Include UniversalNFTCore for URI overrides
        )
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(
        bytes4 interfaceId
    )
        public
        view
        override(
            ERC721Upgradeable,
            ERC721EnumerableUpgradeable,
            ERC721URIStorageUpgradeable,
            UniversalNFTCore // Include UniversalNFTCore for interface overrides
        )
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
```

## Deployment

1. Deploy Universal NFT on ZetaChain. This is a required step, because a
   contract on ZetaChain handles all cross-chain token transfers, even between
   EVM chains.
2. Deploy Universal NFT on a connected EVM chain (for example, Ethereum, Base,
   Polygon or BNB)
3. Run `ZetaChainUniversalNFT.setConnected(zrc20, contractAddress)`, where zrc20
   is the [ZRC-20 contract](/developers/tokens/zrc20) of the gas token of a
   connected EVM chain, this acts as an identifier for a chain, and
   `contractAddress` is the address of a Universal NFT on a connected EVM chain
   (see step 2).
4. Run `EVMUniversalNFT.setUniversal(contractAddress)`, where `contractAddress`
   is an address of a Universal NFT on ZetaChain (see step 1).

You now have two NFT contracts on ZetaChain and on an EVM chain connected. To
add deploy an NFT contract on another EVM chain, repeat steps 2 and 3.

`setConnected` and `setUniversal` steps are required to establish a trusted
connection between Universal NFT contracts on different chains. When accepting a
cross-chain transfer a contract first checks that the transfer is coming from a
trusted contract. On ZetaChain setting connected contract addresses helps the
contract to route cross-chain transfers.

## Gas Fees

EVM → ZetaChain: no cross-chain fee is applied.

ZetaChain → EVM: a cross-chain fee is paid in ZETA. The amount depends on the
ZRC-20 withdraw fee for the destination chain. ZETA is swapped for the
destination chain's gas token ZRC-20.

EVM → EVM: a cross-chain fee is paid in the gas token of the source chain. The
amount depends on the ZRC-20 withdraw fee for the destination chain. For
example, if an NFT is transferred from Ethereum to BNB chain, the cross-chain
fee is paid in ETH. On ZetaChain ZRC-20 ETH is swapped for ZRC-20 BNB, which is
used to cover a call to the BNB chain.

## Revert Handling

EVM → EVM: if a transfer between two EVM chains reverts, the NFT will be
transferred to **the original sender on ZetaChain**. This is prevent potential
high gas fees associated with returning the NFT back to chain from which it was
transferred in the first place. After the revert, the original sender can
transfer the NFT from ZetaChain to any other chain.

## Demo on Testnet

```
npx hardhat compile --force
```

### Deploy

```
ZETACHAIN_NFT=$(npx hardhat nft:deploy \
  --network zeta_testnet \
  --uniswap-router 0x2ca7d64A7EFE2D62A725E2B35Cf7230D6677FfEe \
  --name ZetaChainUniversalNFT \
  --json | jq -r .contractAddress) && echo $ZETACHAIN_NFT
```

```
BASE_NFT=$(npx hardhat nft:deploy \
  --network base_sepolia \
  --gateway 0x0c487a766110c85d301d96e33579c5b317fa4995 \
  --name EVMUniversalNFT \
  --json | jq -r .contractAddress) && echo $BASE_NFT
```

```
ETHEREUM_NFT=$(npx hardhat nft:deploy \
  --network sepolia_testnet \
  --gateway 0x0c487a766110c85d301d96e33579c5b317fa4995 \
  --name EVMUniversalNFT \
  --json | jq -r .contractAddress) && echo $ETHEREUM_NFT
```

### Connect Contracts

```
npx hardhat nft:set-connected \
  --contract $ZETACHAIN_NFT \
  --connected $BASE_NFT \
  --zrc20 $BASE_ZRC20 \
  --network zeta_testnet \
  --json
```

```
npx hardhat nft:set-connected \
  --contract $ZETACHAIN_NFT \
  --connected $ETHEREUM_NFT \
  --zrc20 $ETHEREUM_ZRC20 \
  --network zeta_testnet
```

```
npx hardhat nft:set-universal \
  --contract $BASE_NFT \
  --universal $ZETACHAIN_NFT \
  --network base_sepolia
```

```
npx hardhat nft:set-universal \
  --contract $ETHEREUM_NFT \
  --universal $ZETACHAIN_NFT \
  --network sepolia_testnet
```

### Mint on ZetaChain

```
NFT1=$(npx hardhat nft:mint \
  --contract $ZETACHAIN_NFT \
  --token-uri https://example.org \
  --network zeta_testnet \
  --json | jq -r .tokenId) && echo $NFT1
```

https://zetachain-testnet.blockscout.com/tx/0xc9f8e3a8b3e1f1e2511fae649d510f0ce483dd1b3c481c8b01f066a0ca342458

### Transfer from ZetaChain to Base

Transfer the token from ZetaChain to Base. Gas amount (specified in ZETA) is an
estimate. Unused tokens are refunded to the user.

User ZRC-20 Base ETH as the destination address to specify the chain to which
the NFT will be transferred.

```
npx hardhat nft:transfer \
  --contract $ZETACHAIN_NFT \
  --destination $BASE_ZRC20 \
  --token-id $NFT1 \
  --network zeta_testnet \
  --gas-amount 5
```

```
🚀 Successfully transferred NFT to the contract.
📜 Contract address: 0xb2c095a2e05B5C886041a53b6f3d62736fC2C1Bc
🖼 NFT Contract address: 0xb2c095a2e05B5C886041a53b6f3d62736fC2C1Bc
🆔 Token ID: 269200511667900488584833727349313006688770271102
🔗 Transaction hash: 0x219370f4200c934dd647a1ea27099c25061de2fb25bb13194ec7bd328cdb624e
⛽ Gas used: 500000
```

Outgoing cross-chain transaction from ZetaChain to Base:

https://zetachain-athens.blockpi.network/lcd/v1/public/zeta-chain/crosschain/inboundHashToCctxData/0x219370f4200c934dd647a1ea27099c25061de2fb25bb13194ec7bd328cdb624e

https://sepolia.basescan.org/tx/0xb56e0fccb95d40e79d6078dbdf2b4e47454e4c6da1dd7a9afb6082e1bd9f1a78

### Transfer from Base to Ethereum

```
npx hardhat nft:transfer \
  --contract $BASE_NFT \
  --network base_sepolia \
  --destination $ETHEREUM_ZRC20 \
  --token-id $NFT1 \
  --gas-amount 0.005
```

```
🚀 Successfully transferred NFT to the contract.
📜 Contract address: 0x7a72AE51CCfAda57B20f8C7d8b138d35E46a2D60
🖼 NFT Contract address: 0x7a72AE51CCfAda57B20f8C7d8b138d35E46a2D60
🆔 Token ID: 269200511667900488584833727349313006688770271102
🔗 Transaction hash: 0x27c3ca27da7576e8b00ceb588c9aa5e5622dcf03273d22c58660268149c445a4
⛽ Gas used: 118428
```

Incoming cross-chain transaction from Base to ZetaChain:

https://zetachain-athens.blockpi.network/lcd/v1/public/zeta-chain/crosschain/inboundHashToCctxData/0x27c3ca27da7576e8b00ceb588c9aa5e5622dcf03273d22c58660268149c445a4

Outgoing cross-chain transaction from ZetaChain to Ethereum:

https://zetachain-athens.blockpi.network/lcd/v1/public/zeta-chain/crosschain/inboundHashToCctxData/0x5cfb1c21201025482909f2bc390e0ada032e2c37d0f8e1861a7e248083c8d015

https://sepolia.etherscan.io/tx/0x171034238d6cfb51c2a8a8e1a023034523d579643d23d9bcbd98c70ad76b1eb9

## Source Code

https://github.com/zeta-chain/standard-contracts/tree/main/contracts/nft
